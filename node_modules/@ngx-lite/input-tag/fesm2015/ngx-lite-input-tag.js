import { InjectionToken, ɵɵgetCurrentView, ɵɵelementStart, ɵɵtext, ɵɵlistener, ɵɵrestoreView, ɵɵnextContext, ɵɵelementEnd, ɵɵadvance, ɵɵtextInterpolate1, ɵɵtextInterpolate, ɵɵtemplate, ɵɵproperty, EventEmitter, ɵɵdirectiveInject, ɵɵdefineComponent, ɵɵviewQuery, ɵɵqueryRefresh, ɵɵloadQuery, ɵɵresolveDocument, ɵɵProvidersFeature, forwardRef, ɵɵreference, ɵɵstyleProp, ɵsetClassMetadata, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, ViewChild, Input, Output, HostListener, ɵɵdefineNgModule, ɵɵdefineInjector, ɵɵsetNgModuleScope, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS } from '@angular/forms';
import { NgForOf, NgIf, CommonModule } from '@angular/common';

const NGX_INPUT_TAG_TAG_FORMATTER = new InjectionToken('NGX_INPUT_TAG_TAG_FORMATTER');

const _c0 = ["inputElement"];
function NgxInputTagComponent_div_1_Template(rf, ctx) { if (rf & 1) {
    const _r5 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "div", 6);
    ɵɵtext(1);
    ɵɵelementStart(2, "button", 7);
    ɵɵlistener("click", function NgxInputTagComponent_div_1_Template_button_click_2_listener($event) { ɵɵrestoreView(_r5); const tag_r3 = ctx.$implicit; const ctx_r4 = ɵɵnextContext(); return ctx_r4.removeTag(tag_r3, $event); });
    ɵɵtext(3, " \u2716 ");
    ɵɵelementEnd();
    ɵɵelementEnd();
} if (rf & 2) {
    const tag_r3 = ctx.$implicit;
    ɵɵadvance(1);
    ɵɵtextInterpolate1(" ", tag_r3, " ");
} }
function NgxInputTagComponent_div_6_button_1_Template(rf, ctx) { if (rf & 1) {
    const _r9 = ɵɵgetCurrentView();
    ɵɵelementStart(0, "button", 10);
    ɵɵlistener("click", function NgxInputTagComponent_div_6_button_1_Template_button_click_0_listener() { ɵɵrestoreView(_r9); const tag_r7 = ctx.$implicit; const ctx_r8 = ɵɵnextContext(2); return ctx_r8.addSuggestedTag(tag_r7); });
    ɵɵtext(1);
    ɵɵelementEnd();
} if (rf & 2) {
    const tag_r7 = ctx.$implicit;
    ɵɵadvance(1);
    ɵɵtextInterpolate(tag_r7);
} }
function NgxInputTagComponent_div_6_Template(rf, ctx) { if (rf & 1) {
    ɵɵelementStart(0, "div", 8);
    ɵɵtemplate(1, NgxInputTagComponent_div_6_button_1_Template, 2, 1, "button", 9);
    ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r2 = ɵɵnextContext();
    ɵɵadvance(1);
    ɵɵproperty("ngForOf", ctx_r2.tagSuggestions);
} }
var KeyCodes;
(function (KeyCodes) {
    KeyCodes[KeyCodes["Backspace"] = 8] = "Backspace";
    KeyCodes[KeyCodes["Tab"] = 9] = "Tab";
    KeyCodes[KeyCodes["Enter"] = 13] = "Enter";
    KeyCodes[KeyCodes["Escape"] = 27] = "Escape";
    KeyCodes[KeyCodes["LeftArrow"] = 37] = "LeftArrow";
    KeyCodes[KeyCodes["UpArrow"] = 38] = "UpArrow";
    KeyCodes[KeyCodes["RightArrow"] = 39] = "RightArrow";
    KeyCodes[KeyCodes["DownArrow"] = 40] = "DownArrow";
    KeyCodes[KeyCodes["Comma"] = 188] = "Comma";
})(KeyCodes || (KeyCodes = {}));
class NgxInputTagComponent {
    constructor(tagFormatter) {
        this.tagFormatter = tagFormatter;
        this.tagSuggestions = [];
        this.maxTagLength = 25;
        this.maxNumberOfTags = 1000;
        this.textChange = new EventEmitter();
        this._value = [];
        this.prevTagInput = '';
        this.currentNumberOfTags = 0;
        this.tagError = null;
        this.onChange = (_value) => { };
        this.onTouched = () => { };
    }
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val;
        this.onChange(val);
        this.onTouched();
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    writeValue(value) {
        if (value) {
            this.value = value.map((v) => this.tagFormatter(v));
            this.setCurrentNumberOfTags();
        }
    }
    validate() {
        return this.tagError;
    }
    handleClick(event) {
        if (this.inputElement &&
            !this.inputElement.nativeElement.contains(event.target) &&
            this.inputElement.nativeElement.value) {
            this.addTag(this.inputElement.nativeElement.value);
        }
    }
    addTag(tag) {
        const formattedTag = this.tagFormatter(tag);
        const tagIsEmpty = formattedTag.length === 0;
        const invalidTagLength = !formattedTag.length ||
            (this.maxTagLength && formattedTag.length > this.maxTagLength);
        const duplicateTag = this.value.indexOf(formattedTag) > -1;
        const exceedsMaxNumberOfTags = this.currentNumberOfTags > this.maxNumberOfTags;
        if (!tagIsEmpty && invalidTagLength) {
            this.tagError = {
                message: `Tag length cannot exceed ${this.maxTagLength} characters`,
            };
        }
        if (duplicateTag) {
            this.tagError = { message: 'Cannot add duplicate tag' };
        }
        if (exceedsMaxNumberOfTags) {
            const plural = this.maxNumberOfTags === 1 ? '' : 's';
            this.tagError = {
                message: `Cannot exceed ${this.maxNumberOfTags} tag${plural}`,
            };
        }
        if (!tagIsEmpty &&
            !invalidTagLength &&
            !duplicateTag &&
            !exceedsMaxNumberOfTags &&
            this.inputElement) {
            this.tagError = null;
            this.value.push(formattedTag);
            this.setCurrentNumberOfTags();
            this.inputElement.nativeElement.value = '';
        }
        this.value = this.value;
        this.focus();
    }
    addTagEvent(event) {
        const input = event.target;
        this.tagError = null;
        this.value = this.value;
        this.textChange.emit(input.value);
        if (event.keyCode === KeyCodes.Backspace &&
            this.prevTagInput.length === 0) {
            this._value.pop();
            this.setCurrentNumberOfTags();
        }
        else if (event.keyCode === KeyCodes.Enter ||
            event.keyCode === KeyCodes.Comma ||
            event.keyCode === KeyCodes.Tab) {
            this.addTag(input.value);
        }
        this.prevTagInput = input.value;
    }
    preventDefaultTabBehavior(event) {
        if (event.keyCode === KeyCodes.Tab && this.prevTagInput.length > 0) {
            event.preventDefault();
        }
    }
    addTagClick(event, value) {
        event.preventDefault();
        if (value.length > 0) {
            this.addTag(value);
        }
    }
    addSuggestedTag(tag) {
        this.addTag(tag);
    }
    removeTag(tag, event) {
        if (event.keyCode !== KeyCodes.Enter) {
            this.value = this._value.filter((t) => t !== tag);
            this.setCurrentNumberOfTags();
        }
    }
    focus() {
        var _a;
        (_a = this.inputElement) === null || _a === void 0 ? void 0 : _a.nativeElement.focus();
    }
    setCurrentNumberOfTags() {
        this.currentNumberOfTags = this.value.length
            ? this.value.toString().split(',').length
            : 0;
    }
}
NgxInputTagComponent.ɵfac = function NgxInputTagComponent_Factory(t) { return new (t || NgxInputTagComponent)(ɵɵdirectiveInject(NGX_INPUT_TAG_TAG_FORMATTER)); };
NgxInputTagComponent.ɵcmp = ɵɵdefineComponent({ type: NgxInputTagComponent, selectors: [["ngx-input-tag"]], viewQuery: function NgxInputTagComponent_Query(rf, ctx) { if (rf & 1) {
        ɵɵviewQuery(_c0, true);
    } if (rf & 2) {
        let _t;
        ɵɵqueryRefresh(_t = ɵɵloadQuery()) && (ctx.inputElement = _t.first);
    } }, hostBindings: function NgxInputTagComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵɵlistener("click", function NgxInputTagComponent_click_HostBindingHandler($event) { return ctx.handleClick($event); }, false, ɵɵresolveDocument);
    } }, inputs: { tagSuggestions: "tagSuggestions", maxTagLength: "maxTagLength", maxNumberOfTags: "maxNumberOfTags" }, outputs: { textChange: "textChange" }, features: [ɵɵProvidersFeature([
            {
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => NgxInputTagComponent),
                multi: true,
            },
            {
                provide: NG_VALIDATORS,
                useExisting: forwardRef(() => NgxInputTagComponent),
                multi: true,
            },
        ])], decls: 7, vars: 4, consts: [[1, "ngx-input-tag", 3, "click"], ["class", "ngx-input-tag__tag", 4, "ngFor", "ngForOf"], ["type", "text", "aria-label", "Tags", 1, "ngx-input-tag__input", 3, "keyup", "keydown"], ["inputElement", ""], ["type", "button", "aria-label", "Add Tag", "title", "Add Tag", 1, "ngx-input-tag__btn", 3, "click"], ["class", "ngx-input-tag-suggestions", 4, "ngIf"], [1, "ngx-input-tag__tag"], ["type", "button", 3, "click"], [1, "ngx-input-tag-suggestions"], ["type", "button", "class", "ngx-input-tag-suggestions__tag", 3, "click", 4, "ngFor", "ngForOf"], ["type", "button", 1, "ngx-input-tag-suggestions__tag", 3, "click"]], template: function NgxInputTagComponent_Template(rf, ctx) { if (rf & 1) {
        const _r10 = ɵɵgetCurrentView();
        ɵɵelementStart(0, "div", 0);
        ɵɵlistener("click", function NgxInputTagComponent_Template_div_click_0_listener() { return ctx.focus(); });
        ɵɵtemplate(1, NgxInputTagComponent_div_1_Template, 4, 1, "div", 1);
        ɵɵelementStart(2, "input", 2, 3);
        ɵɵlistener("keyup", function NgxInputTagComponent_Template_input_keyup_2_listener($event) { return ctx.addTagEvent($event); })("keydown", function NgxInputTagComponent_Template_input_keydown_2_listener($event) { return ctx.preventDefaultTabBehavior($event); });
        ɵɵelementEnd();
        ɵɵelementStart(4, "button", 4);
        ɵɵlistener("click", function NgxInputTagComponent_Template_button_click_4_listener($event) { ɵɵrestoreView(_r10); const _r1 = ɵɵreference(3); return ctx.addTagClick($event, _r1.value); });
        ɵɵtext(5, " + ");
        ɵɵelementEnd();
        ɵɵelementEnd();
        ɵɵtemplate(6, NgxInputTagComponent_div_6_Template, 2, 1, "div", 5);
    } if (rf & 2) {
        const _r1 = ɵɵreference(3);
        ɵɵadvance(1);
        ɵɵproperty("ngForOf", ctx.value);
        ɵɵadvance(1);
        ɵɵstyleProp("width", _r1.value.length * 10 + 10 + "px");
        ɵɵadvance(4);
        ɵɵproperty("ngIf", _r1.value.length && ctx.tagSuggestions && ctx.tagSuggestions.length);
    } }, directives: [NgForOf, NgIf], styles: ["*,:after,:before{box-sizing:border-box}ngx-input-tag{--color-add-button:#ccc;--color-add-button-background:#fff;--color-background:#fff;--color-border:#dbdbdb;--color-tag-close:#ccc;--color-tag-suggestion-hover:#f2f2f2;display:inline-block;margin-bottom:12px;width:100%}.ngx-input-tag{background-color:#fff;background-color:var(--color-background);border:1px solid #dbdbdb;border:1px solid var(--color-border);font-size:16px;margin-bottom:0;padding:5px 80px 4.5px 4px;position:relative}.ngx-input-tag:focus{outline:initial}.ngx-input-tag__input{border:0;font-size:16px;margin-bottom:0;margin-left:4px;max-width:calc(100% + 70px);min-height:29px;min-width:4px;outline:none;padding:4px 0;width:8px}.ngx-input-tag__tag{border:1px solid #dbdbdb;border:1px solid var(--color-border);border-radius:2px;display:inline-block;height:29px;line-height:18px;margin-right:4px;padding:4px}.ngx-input-tag__tag button{background:transparent;border:0;color:var(--color-tag-close);cursor:pointer}.ngx-input-tag__btn{background-color:#fff;background-color:var(--color-add-button-background);color:#ccc;color:var(--color-add-button);cursor:pointer;font-size:30px;height:41px;position:absolute;right:-1px;top:-1px;width:50px}.ngx-input-tag-suggestions,.ngx-input-tag__btn{border:1px solid #dbdbdb;border:1px solid var(--color-border)}.ngx-input-tag-suggestions{background-color:#fff;background-color:var(--color-background)}.ngx-input-tag-suggestions__tag{background:transparent;border:0;cursor:pointer;display:block;padding:10px 14px;text-align:left;width:100%}.ngx-input-tag-suggestions__tag:hover{background:#f2f2f2;background:var(--color-tag-suggestion-hover)}"], encapsulation: 2, changeDetection: 0 });
/*@__PURE__*/ (function () { ɵsetClassMetadata(NgxInputTagComponent, [{
        type: Component,
        args: [{
                selector: 'ngx-input-tag',
                templateUrl: './ngx-input-tag.component.html',
                styleUrls: ['./ngx-input-tag.component.scss'],
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NgxInputTagComponent),
                        multi: true,
                    },
                    {
                        provide: NG_VALIDATORS,
                        useExisting: forwardRef(() => NgxInputTagComponent),
                        multi: true,
                    },
                ],
                encapsulation: ViewEncapsulation.None,
            }]
    }], function () { return [{ type: undefined, decorators: [{
                type: Inject,
                args: [NGX_INPUT_TAG_TAG_FORMATTER]
            }] }]; }, { inputElement: [{
            type: ViewChild,
            args: ['inputElement', { static: false }]
        }], tagSuggestions: [{
            type: Input
        }], maxTagLength: [{
            type: Input
        }], maxNumberOfTags: [{
            type: Input
        }], textChange: [{
            type: Output
        }], handleClick: [{
            type: HostListener,
            args: ['document:click', ['$event']]
        }] }); })();
function formatter(tag) {
    return tag
        .trim()
        .replace(/(\s|-)+/g, '-')
        .replace(/\,/g, '')
        .toLowerCase();
}

class NgxInputTagModule {
    static forRoot(config = { tagFormatter: formatter }) {
        return {
            ngModule: NgxInputTagModule,
            providers: [
                {
                    provide: NGX_INPUT_TAG_TAG_FORMATTER,
                    useValue: config.tagFormatter,
                },
            ],
        };
    }
}
NgxInputTagModule.ɵmod = ɵɵdefineNgModule({ type: NgxInputTagModule });
NgxInputTagModule.ɵinj = ɵɵdefineInjector({ factory: function NgxInputTagModule_Factory(t) { return new (t || NgxInputTagModule)(); }, imports: [[CommonModule]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵɵsetNgModuleScope(NgxInputTagModule, { declarations: [NgxInputTagComponent], imports: [CommonModule], exports: [NgxInputTagComponent] }); })();
/*@__PURE__*/ (function () { ɵsetClassMetadata(NgxInputTagModule, [{
        type: NgModule,
        args: [{
                imports: [CommonModule],
                declarations: [NgxInputTagComponent],
                exports: [NgxInputTagComponent],
            }]
    }], null, null); })();

/*
 * Public API Surface of ngx-input-tag
 */

/**
 * Generated bundle index. Do not edit.
 */

export { KeyCodes, NGX_INPUT_TAG_TAG_FORMATTER, NgxInputTagComponent, NgxInputTagModule, formatter };
//# sourceMappingURL=ngx-lite-input-tag.js.map
