"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _flattenDeep = _interopRequireDefault(require("lodash/flattenDeep"));

var _isNil = _interopRequireDefault(require("lodash/isNil"));

var _last = _interopRequireDefault(require("lodash/last"));

var _omit = _interopRequireDefault(require("lodash/omit"));

var _pick = _interopRequireDefault(require("lodash/pick"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const isTextElement = tag => typeof tag === 'string' || typeof tag === 'number';

const isTopLevelElement = elementName => ['header', 'content', 'footer'].includes(elementName);

function updateContext(context, overrides) {
  return Object.assign(context, overrides);
}

function createContext(parentContext = {}) {
  return _objectSpread({}, parentContext);
}

function createElement(elementName, attributes, ...children) {
  const flatChildren = (0, _flattenDeep.default)(children);
  return {
    elementName,
    children: flatChildren,
    attributes: attributes || {}
  };
}

function resolve(tag, context) {
  let resolvedTag = tag;

  while (resolvedTag && typeof resolvedTag.elementName === 'function') {
    resolvedTag = resolvedTag.elementName(_objectSpread(_objectSpread({}, resolvedTag.attributes), {}, {
      children: resolvedTag.children
    }), context, updateContext.bind(null, context));
  }

  return resolvedTag;
}

function unwrapTextElements(elements) {
  if (elements.length === 1 && isTextElement(elements[0])) {
    return elements[0];
  }

  return elements;
}

function resolveChildren(tag, parentContext, isTopLevel) {
  const resolvedTag = resolve(tag, parentContext);

  if (!resolvedTag) {
    return null;
  }

  if (isTextElement(resolvedTag)) {
    return resolvedTag;
  }

  const {
    elementName,
    children = [],
    attributes
  } = resolvedTag;

  if (!isTopLevel && isTopLevelElement(elementName)) {
    throw new Error('<header>, <content> and <footer> elements can only appear as immediate descendents of the <document>');
  }

  if (isTopLevel && !isTopLevelElement(elementName)) {
    throw new Error(`The <document> element can only contain <header>, <content>, and <footer> elements but found ${elementName}`);
  }

  if (['header', 'footer'].includes(elementName) && children.length === 1 && typeof children[0] === 'function') {
    return (...args) => _objectSpread({
      stack: [resolveChildren(children[0](...args), createContext(parentContext))]
    }, attributes);
  }

  const resolvedChildren = children.reduce((accumulator, child) => {
    const resolvedChild = resolveChildren(child, createContext(parentContext));

    if (isTextElement((0, _last.default)(accumulator)) && isTextElement(resolvedChild)) {
      // If the previous child is a string
      // and the next child is a string,
      // join them together.
      accumulator[accumulator.length - 1] = `${accumulator[accumulator.length - 1]}${resolvedChild}`;
    } else if (!(0, _isNil.default)(resolvedChild)) {
      // Otherwise push the child onto
      // the accumulator (as long as it's
      // not null or undefined).
      accumulator.push(resolvedChild);
    }

    return accumulator;
  }, []);
  /**
   * This is the meat. If you're in this file, you're probably looking for this.
   *
   * Converts the React-like syntax to something PDFMake understands.
   */

  switch (elementName) {
    case 'header':
    case 'content':
    case 'footer':
    case 'stack':
    case 'column':
    case 'cell':
      return _objectSpread({
        stack: resolvedChildren
      }, attributes);

    case 'text':
      return _objectSpread({
        text: unwrapTextElements(resolvedChildren)
      }, attributes);

    case 'columns':
      return _objectSpread({
        columns: resolvedChildren
      }, attributes);

    case 'image':
      return _objectSpread({
        image: attributes.src
      }, (0, _omit.default)(attributes, 'src'));

    case 'svg':
      return _objectSpread({
        svg: attributes.content
      }, (0, _omit.default)(attributes, 'content'));

    case 'qr':
      return _objectSpread({
        qr: attributes.content
      }, (0, _omit.default)(attributes, 'content'));

    case 'table':
      return _objectSpread({
        table: _objectSpread({
          body: resolvedChildren
        }, (0, _pick.default)(attributes, ['headerRows', 'widths']))
      }, (0, _omit.default)(attributes, ['headerRows', 'widths']));

    case 'row':
      return resolvedChildren;

    case 'ul':
      return _objectSpread({
        ul: resolvedChildren
      }, attributes);

    case 'ol':
      return _objectSpread({
        ol: resolvedChildren
      }, attributes);

    case 'document':
      throw new Error('<document> can only appear as the root element');

    default:
      return null;
  }
}
/*
 * Recursively traverse the JSON component tree created by the createElement calls,
 * resolving components from the bottom up.
 */


function renderPdf(tag) {
  const context = createContext();
  const resolvedTag = resolve(tag, context);
  const {
    children,
    elementName,
    attributes
  } = resolvedTag;

  if (elementName !== 'document') {
    throw new Error(`The root element must resolve to a <document>, actually resolved to ${elementName}`);
  }

  const result = {};
  const isTopLevel = true;
  children.forEach(child => {
    const resolvedChild = resolve(child, context);
    result[resolvedChild.elementName] = resolveChildren(resolvedChild, context, isTopLevel);
  });
  return _objectSpread(_objectSpread({}, result), attributes);
}

const Fragment = props => createElement('stack', null, props.children);

var _default = {
  createElement,
  renderPdf,
  Fragment
};
exports.default = _default;